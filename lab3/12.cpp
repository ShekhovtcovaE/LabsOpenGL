
#include <windows.h>      //Заголовочный файл для Windows
#include <stdio.h>        //Заголовочный файл стандартного ввода/вывода
#include <gl\gl.h>        //Заголовочный файл библиотеки OpenGL32
#include <gl\glu.h>       //Заголовочный файл библиотеки GLu32
#include <gl\glaux.h>     //Заголовочный файл библиотеки GLaux

HDC             hDC=NULL;       //Приватный контекст GDI устройства

HGLRC           hRC=NULL;       //Постоянный контекст отображения
HWND            hWnd=NULL;      //Содержит дискриптор нашего окна
HINSTANCE       hInstance;      //Содержит экземпляр приложения

bool    keys[256];              //Массив применяемый для подпрограммы клавиатуры
bool    active=TRUE;            //Флаг "Активное" окна устанавливается истинным (TRUE)
                                // по умолчанию.
bool    fullscreen=TRUE;        //Флаг "На полный экран" устанавливается в полноэкранный
                                // режим по умолчанию.

GLuint  texture[1];     // Память для одной текстуры
GLuint  box;            // Память для списка отображения box (коробка)
GLuint  top;            // Память для второго списка отображения top (крышка)
GLuint  xloop;  // Цикл для оси x
GLuint  yloop;  // Цикл для оси y

GLfloat xrot;   // Вращает куб на оси x
GLfloat yrot;   // Вращает куб на оси y


static GLfloat boxcol[5][3]=    //Массив для цветов коробки
{

//Яркие: Красный, Оранжевый, Желтый, Зеленый, Голубой
{1.0f,0.0f,0.0f},{1.0f,0.5f,0.0f},{1.0f,1.0f,0.0f},{0.0f,1.0f,0.0f},{0.0f,1.0f,1.0f}
};

static GLfloat topcol[5][3]=    //Массив для цветов верха
{
//Темные: Красный, Оранжевый, Желтый, Зеленый, Голубой
{.5f,0.0f,0.0f},{0.5f,0.25f,0.0f},{0.5f,0.5f,0.0f},{0.0f,0.5f,0.0f},{0.0f,0.5f,0.5f}
};

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); //Объявление для WndProc


GLvoid BuildLists()     //создаем список отображения
{


box=glGenLists(2);      //создаем два списка

Т
glNewList(box,GL_COMPILE);      // Новый откомпилированный список отображения box


glBegin(GL_QUADS);      // Начинаем рисование четырехугольников (quads)
                        // Нижняя поверхность
glTexCoord2f(1.0f, 1.0f);
glVertex3f(-1.0f, -1.0f, -1.0f);        // Верхний правый угол текстуры и четырехугольник
glTexCoord2f(0.0f, 1.0f);
glVertex3f( 1.0f, -1.0f, -1.0f);        // Верхний левый угол текстуры и четырехугольник
glTexCoord2f(0.0f, 0.0f);
glVertex3f( 1.0f, -1.0f, 1.0f);        // Нижний левый угол текстуры и четырехугольник
glTexCoord2f(1.0f, 0.0f);
glVertex3f(-1.0f, -1.0f, 1.0f);        // Нижний правый угол текстуры и четырехугольник
                        // Передняя поверхность
glTexCoord2f(0.0f, 0.0f);
glVertex3f(-1.0f, -1.0f, 1.0f);        // Нижний левый угол текстуры и четырехугольник
glTexCoord2f(1.0f, 0.0f);
glVertex3f( 1.0f, -1.0f, 1.0f);        // Нижний правый угол текстуры и четырехугольник
glTexCoord2f(1.0f, 1.0f);
glVertex3f( 1.0f, 1.0f, 1.0f);        // Верхний правый угол текстуры и четырехугольник
glTexCoord2f(0.0f, 1.0f);
glVertex3f(-1.0f, 1.0f, 1.0f);        // Верхний левый угол текстуры и четырехугольник
                        // Задняя поверхность
glTexCoord2f(1.0f, 0.0f);
glVertex3f(-1.0f, -1.0f, -1.0f);        // Нижний правый угол текстуры и четырехугольник
glTexCoord2f(1.0f, 1.0f);
glVertex3f(-1.0f, 1.0f, -1.0f);        // Верхний правый угол текстуры и четырехугольник
glTexCoord2f(0.0f, 1.0f);
glVertex3f( 1.0f, 1.0f, -1.0f);        // Верхний левый угол текстуры и четырехугольник
glTexCoord2f(0.0f, 0.0f);
glVertex3f( 1.0f, -1.0f, -1.0f);        // Нижний левый угол текстуры и четырехугольник
                        // Правая поверхность
glTexCoord2f(1.0f, 0.0f);
glVertex3f( 1.0f, -1.0f, -1.0f);        // Нижний правый угол текстуры и четырехугольник
glTexCoord2f(1.0f, 1.0f);
glVertex3f( 1.0f, 1.0f, -1.0f);        // Верхний правый угол текстуры и четырехугольник
glTexCoord2f(0.0f, 1.0f);
glVertex3f( 1.0f, 1.0f, 1.0f);        // Верхний левый угол текстуры и четырехугольник
glTexCoord2f(0.0f, 0.0f);
glVertex3f( 1.0f, -1.0f, 1.0f);        // Нижний левый угол текстуры и четырехугольник
                        // Левая поверхность
glTexCoord2f(0.0f, 0.0f);
glVertex3f(-1.0f, -1.0f, -1.0f);        // Нижний левый угол текстуры и четырехугольник
glTexCoord2f(1.0f, 0.0f);
glVertex3f(-1.0f, -1.0f, 1.0f);        // Нижний правый угол текстуры и четырехугольник
glTexCoord2f(1.0f, 1.0f);
glVertex3f(-1.0f, 1.0f, 1.0f);        // Верхний правый угол текстуры и четырехугольник
glTexCoord2f(0.0f, 1.0f);
glVertex3f(-1.0f, 1.0f, -1.0f);        // Верхний левый угол текстуры и четырехугольник
glEnd();                        // Закончили рисование четырехугольников


glEndList(); // Закончили создание списка box


top=box+1; // Значение top это значение box + 1


glNewList(top,GL_COMPILE);// Новый откомпилированный список отображения 'top'


glBegin(GL_QUADS);      // Начинаем рисование четырехугольника
                        // Верхняя поверхность
glTexCoord2f(0.0f, 1.0f);
glVertex3f(-1.0f, 1.0f, -1.0f);        // Верхний левый угол текстуры и четырехугольник
glTexCoord2f(0.0f, 0.0f);
glVertex3f(-1.0f, 1.0f, 1.0f);        // Нижний левый угол текстуры и четырехугольник
glTexCoord2f(1.0f, 0.0f);
glVertex3f( 1.0f, 1.0f, 1.0f);        // Нижний правый угол текстуры и четырехугольник
glTexCoord2f(1.0f, 1.0f);
glVertex3f( 1.0f, 1.0f, -1.0f);        // Верхний правый угол текстуры и четырехугольник
glEnd();                // Заканчиваем рисование четырехугольника


        glEndList();            // Закончили создание списка отображения 'top'
}


if (TextureImage[0]=LoadBMP("Data/Cube.bmp"))           // Загрузить картинку.


int InitGL(GLvoid)// Все настройки OpenGL начинаются здесь
{
        if (!LoadGLTextures())// Переход к процедуре загрузки текстуры
        {
                return FALSE;// Если текстура не загружена возращает FALSE
        }
        BuildLists();// Переход к коду, который создает наши списки отображения
       glEnable(GL_TEXTURE_2D);// Включение нанесения текстур
        glShadeModel(GL_SMOOTH);// Включение гладкой закраски (smooth shading)
        glClearColor(0.0f, 0.0f, 0.0f, 0.5f);// Черный фон
        glClearDepth(1.0f);// Установка буфера глубины
        glEnable(GL_DEPTH_TEST);// Включение проверки глубины
        glDepthFunc(GL_LEQUAL); // Тип выполняемой проверки глубины


glEnable(GL_LIGHT0); // Быстрое простое освещение
                        // (устанавливает в качестве источника освещения Light0)
glEnable(GL_LIGHTING);  // Включает освещение
glEnable(GL_COLOR_MATERIAL);    // Включает раскрашивание материала


glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);      // Изящная коррекция перспективы
return TRUE;                                            // Инициализация прошла OK
}


int DrawGLScene(GLvoid)                 // Здесь мы выполняем все рисование
{
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);     // Очищаем экран и буфер глубины

glBindTexture(GL_TEXTURE_2D, texture[0]);               // Выбираем текстуру

        for (yloop=1;yloop<6;yloop++)                           // Цикл по плоскости Y
        {


                for (xloop=0;xloop< yloop;xloop++)              // Цикл по плоскости X
                {


                        glLoadIdentity();                       // Очистка вида


                        // Размещение кубиков на экране
glTranslatef(1.4f+(float(xloop)*2.8f)-(float(yloop)*1.4f),
        ((6.0f-float(yloop))*2.4f)-7.0f,-20.0f);



glRotatef(45.0f-(2.0f*yloop)+xrot,1.0f,0.0f,0.0f);      // Наклонять кубы вверх и вниз
glRotatef(45.0f+yrot,0.0f,1.0f,0.0f);                   // Вращать кубы вправо и влево


glColor3fv(boxcol[yloop-1]);            // Выбор цвета коробки


glCallList(box);                        // Рисуем коробку


glColor3fv(topcol[yloop-1]);            // Выбор цвета верха



                        glCallList(top);                        // Рисуем крышку
                }
        }
        return TRUE;                                            // Возвращаемся обратно.

}


                SwapBuffers(hDC);       // Поменяем буферы (Двойная буферизация)
                if (keys[VK_LEFT])      // Была нажата стрелка влево?
                {
                        yrot-=0.2f;     // Если так, то повернем кубы влево
                }
                if (keys[VK_RIGHT])     // Была нажата стрелка вправо?
                {
                        yrot+=0.2f;     // Если так, то повернем кубы вправо
                }
                if (keys[VK_UP])        // Была нажата стрелка вверх?
                {
                        xrot-=0.2f;     // Если так, то наклоним кубы вверх
                }
                if (keys[VK_DOWN])      // Была нажата стрелка вниз?
                {
                        xrot+=0.2f;     // Если так, то наклоним кубы вниз
                }


                if (keys[VK_F1])                // Была нажата кнопка F1?
                {
                        keys[VK_F1]=FALSE;// Если так - установим значение FALSE
                        KillGLWindow(); // Закроем текущее окно OpenGL
                        // Переключим режим "Полный экран"/"Оконный"
                        fullscreen=!fullscreen;
                        // Заново создадим наше окно OpenGL
                        if (!CreateGLWindow("NeHe's Display List Tutorial",
                                640,480,16,fullscreen))
                        {
                                return 0;// Выйти, если окно не было создано
                        }
                }
        }
}
